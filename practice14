let rec fib = function
  | 0 -> 1
  | 1 -> 1
  | n -> fib (n - 1) + fib (n - 2);;
  
# fib 1;;
- : int = 1

# fib 3;;
- : int = 3

# fib 5;;
- : int = 8

# fib 6;;
- : int = 13

https://exercism.io/tracks/ocaml

 
The Language of Types
https://www2.lib.uchicago.edu/keith/ocaml-class/type-sublanguage.html
https://www2.lib.uchicago.edu/keith/ocaml-class/why.html

https://thealmarty.com/2018/06/12/imperative-programming-in-ocaml/

http://www.lsv.fr/~halfon/TP_Prog/OCaml.pdf
http://www.cs.cornell.edu/courses/cs3110/2018fa/textbook/intro/ocaml.html
http://www.cs.cornell.edu/courses/cs3110/2018fa/textbook/basics/interacting.html


# let empty = [];;
val empty : 'a list = []

# 3::empty;;
- : int list = [3]

# let f x y = x + y;;
val f : int -> int -> int = <fun>

# f 3 4;;
- : int = 7

# f 9 88;;
- : int = 97

# let x = [ 2; 8; 5; ];;
val x : int list = [2; 8; 5]

# List.length x;;
- : int = 3

# List.hd x;;
- : int = 2

# List.tl x;;
- : int list = [8; 5]

# 4::x;;
- : int list = [4; 2; 8; 5]

# 1::9::4::x;;
- : int list = [1; 9; 4; 2; 8; 5]

# [ 2; 8; 5; ] @ [ 3; 4; ]
  ;;
- : int list = [2; 8; 5; 3; 4]

# type person = {mutable name:string; mutable age:int };;
type person = { mutable name : string; mutable age : int; }

# let mj = {name="Mary Jane"; age=19 };;
val mj : person = {name = "Mary Jane"; age = 19}

# print_string mj.name;;
Mary Jane- : unit = ()

# fun x y -> x +. y ;;
- : float -> float -> float = <fun>

# (fun x y -> x +. y) 3. 4. ;;
- : float = 7.

# let rec f n = if n == 1 then 1 else n * f (n-1);;
val f : int -> int = <fun>
# f 20;;
- : int = 2432902008176640000
#

# let rec f n = match n with 0 -> 0 | 1 -> 1 | x -> f (n-1) + f (n-2);;
val f : int -> int = <fun>
# f 20;;
- : int = 6765
#

http://caml.inria.fr/pub/docs/oreilly-book/

# let imm_stack init = object
    val v = init

      method pop =
        match v with
        | hd :: tl -> Some (hd, {< v = tl >})
      | [] -> None

      method push hd =
      {< v = hd :: v >}
      end ;;
      
val imm_stack :
  'a list -> (< pop : ('a * 'b) option; push : 'a -> 'b > as 'b) = <fun>
  
# let s = imm_stack [3; 2; 1] ;;
val s : < pop : (int * 'a) option; push : int -> 'a > as 'a = <obj>
# let t = s#push 4 ;;
val t : < pop : (int * 'a) option; push : int -> 'a > as 'a = <obj>
# s#pop ;;
- : (int * (< pop : 'a; push : int -> 'b > as 'b)) option as 'a =
Some (3, <obj>)
#  t#pop ;;
- : (int * (< pop : 'a; push : int -> 'b > as 'b)) option as 'a =
Some (4, <obj>)




# let plus = ( + );;
val plus : int -> int -> int = <fun>

# plus 2 3;;
- : int = 5

#  List.map (plus 2) [1; 2; 3];;
- : int list = [3; 4; 5]


#  List.map (plus 3) [8;9;100];;
- : int list = [11; 12; 103]
















