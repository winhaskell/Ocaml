Why Ocaml?

Objective Caml is a language that I discovered about three years ago. It is a functional language with imperative features,
remarkably concise, and compiles to native code.
Back then I was using two languages: C, which I hated, and Python, which I loved. The thing is, python is interpreted, 
and therefore too slow for a lot of tasks, so I was forced to use C. But reading about Python,
I learned that many of its features -- in particular, the list manipulation -- were borrowed from functional languages. 
And reading about functional languages led me to Ocaml.

It takes a while to start thinking in the "functional" paradigm: it's a completely different way of programming.
But I quickly realised that a lot of the programming errors I made in C just didn't happen in Ocaml.
A lot of the book-keeping work was just not necessary. Thanks to type-inferencing, I didn't need to declare variables, 
but type mismatches were caught anyway. I didn't need to "garbage collect". 
Programs were about as short in ocaml as in python. But they ran ten times faster, because they were native binaries
generated by a remarkably efficient compiler.

I wrote the first version of Sigma in about a week (and not full-time either); at that time it was basically 
a learning exercise for me. But I was stunned at what I had done, and how fast it ran: it was already competitive, 
in speed and quality, with a lot of other programs I had used.

So I had it all in ocaml: the conciseness of python, and the speed of a compiled language. What's not to like?


Why not Ocaml?

Well, the functional approach doesn't fit every task: sometimes you need mutable variables, for-loops, and so on.
It's hard to do linear algebra, dynamic programming, and many other tasks in a purely functional style.
Ocaml has imperative features, including mutable variables and for-loops and so on, and Sigma uses them liberally; 
but the syntax is decidedly less elegant and it becomes hard to read.
Another major inelegance in Ocaml is its solution for type-safety of mixed expressions involving integers and floats.
It requires ints to be cast to floats ("float_of_int n") before being used in floating-point expressions.
And, worse, it requires separate arithmetic operators for floats, which are the int operations followed 
by a dot, such as "*.". So you have monstrosities like "(float n) *. x" for what would be n*x in C.

And, finally, while Ocaml is fast (the computer language shootout page has it almost as fast as C in many benchmarks), 
for me C just turned out to be faster, often by a factor of 3 or 4. Several times I re-wrote an ocaml program in C,
and it did in 4 hours what the ocaml version did in 12 or 16. Part of the speed gain was due to more efficient 
data structures, or more efficient use of data structures, etc, that I do (almost unconsciously) in C: for example,
avoiding frequent free-ing and re-allocating of memory. It is likely possible to do this in ocaml, but I'm not 
sufficiently expert at it, and if I try it makes the code very ugly.

Having written sigma once in ocaml, it didn't take me long to rewrite it in C; and it was much cleaner than if I 
had written it in C to begin with. Learning ocaml has also made my C coding style much more elegant and less
error-prone. Next I plan to learn Haskell, a "pure" (no imperative features, unlike ocaml), "lazy" (call-by-need)
functional language.

Rahul Siddharthan


https://www.imsc.res.in/~rsidd/ocaml.html

