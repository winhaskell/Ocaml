# let adjacent = [|
  [5; 7];
      [6; 8];
    [3; 7];
    [2; 8; 10];
    [9; 11];
    [0; 6; 10];
    [1; 5; 11];
    [0; 2];
    [1; 3; 9];
    [4; 8];
    [3; 5];
    [4; 6]
  |];;
val adjacent : int list array =
  [|[5; 7]; [6; 8]; [3; 7]; [2; 8; 10]; [9; 11]; [0; 6; 10]; [1; 5; 11];
    [0; 2]; [1; 3; 9]; [4; 8]; [3; 5]; [4; 6]|]
# let print_path path =
  List.iter (fun x -> print_int x; print_string " ") path;
      print_newline ();;
val print_path : int list -> unit = <fun>
# let rec dfs n path =
  if n = 12 then print_path (List.rev path)
      else
    let p = List.hd path in
      List.iter (fun x -> if List.mem x path then () else dfs (n+1) (x::path))
                  adjacent.(p);;
val dfs : int -> int list -> unit = <fun>
# let () = dfs 1 [0];;
0 7 2 3 10 5 6 1 8 9 4 11
0 7 2 3 10 5 6 11 4 9 8 1
#

------------------------------------------------------------------------------------------------------

騎士の巡歴 (Knight's Tour)
騎士はチェスの駒のひとつで、将棋の桂馬の動きを前後左右にとることができます。次の図を見てください。

   ┌─┬─┬─┬─┬─┐
   │  │●│  │●│  │
   ├─┼─┼─┼─┼─┤    ┌─┬─┬─┐ 
   │●│  │  │  │●│    │Ｋ│  │  │ 
   ├─┼─┼─┼─┼─┤    ├─┼─┼─┤ 
   │  │  │Ｋ│  │  │    │  │  │  │ 
   ├─┼─┼─┼─┼─┤    ├─┼─┼─┤ 
   │●│  │  │  │●│    │  │  │  │ 
   ├─┼─┼─┼─┼─┤    ├─┼─┼─┤ 
   │  │●│  │●│  │    │  │  │  │ 
   └─┴─┴─┴─┴─┘    └─┴─┴─┘ 

  ●：騎士 (K) が動ける位置       問題 

            図 5 : 騎士の巡歴
この騎士を動かして、N 行 M 列の盤面のどのマスにもちょうど一回ずつ訪れるような経路を求めるのが問題です。
ちなみに、3 行 3 列、4 行 4 列の盤面には解がありませんが、5 行 5 列の盤面には解があります。大きな盤面を解くのは大変なので、
3 行 4 列の盤面で騎士の移動経路を求めてください。プログラムを作る前に、自分で考えてみるのも面白いでしょう。

それではプログラムを作りましょう。次の図を見てください。

 ┌─┬─┬─┐
 │０│１│２│     ０──７──２
 ├─┼─┼─┤     │          │
 │３│４│５│     ５──10──３
 ├─┼─┼─┤     │          │
 │６│７│８│     ６──１──８
 ├─┼─┼─┤     │          │
 │９│10│11│     11──４──９
 └─┴─┴─┘

（Ａ）３行４列盤    （Ｂ）経路図

        図 6 : 騎士の移動
図 6 (A) のように、3 行 4 列盤の各マスに番号を付けて表します。すると、騎士の移動は (B) のようにグラフで表すことができます。
これならば、コンピュータを使わなくても解くことができますね。プログラムも隣接リストを定義すれば簡単です。
あとは単純な深さ優先探索で騎士の経路を探すだけです。

リスト 4 : 騎士の巡歴 (knight.ml)

(* 隣接リスト *)
let adjacent = [|
  [5; 7];
  [6; 8];
  [3; 7];
  [2; 8; 10];
  [9; 11];
  [0; 6; 10];
  [1; 5; 11];
  [0; 2];
  [1; 3; 9];
  [4; 8];
  [3; 5];
  [4; 6]
|]

(* 経路の表示 *)
let print_path path =
  List.iter (fun x -> print_int x; print_string " ") path;
  print_newline ()

(* 深さ優先探索 *)
let rec dfs n path =
  if n = 12 then print_path (List.rev path)
  else
    let p = List.hd path in
    List.iter (fun x -> if List.mem x path then () else dfs (n+1) (x::path))
              adjacent.(p)

(* 実行 *)
let () = dfs 1 [0]
経路はリストで表します。関数 dfs の引数 n が訪れたマスの個数を表し、次の引数 path が経路を表します。
n が 12 になったら見つけた経路を関数 print_path で表示します。そうでなければ、騎士を次のマスへ進めます。
この処理は経路の探索と同じです。

プログラムはこれだけです。とても簡単ですね。それでは実行してみましょう。

C>knight
0 7 2 3 10 5 6 1 8 9 4 11 
0 7 2 3 10 5 6 11 4 9 8 1 
